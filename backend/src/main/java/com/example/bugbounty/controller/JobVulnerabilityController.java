package com.example.bugbounty.controller;

import com.example.bugbounty.dto.VulnerabilityDTO;
import com.example.bugbounty.entity.Job;
import com.example.bugbounty.entity.Vulnerability;
import com.example.bugbounty.model.TestRequest;
import com.example.bugbounty.repository.JobRepository;
import com.example.bugbounty.repository.VulnerabilityRepository;
import com.example.bugbounty.service.VulnerabilityService;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "*")
@RequiredArgsConstructor
public class JobVulnerabilityController {

    private static final Logger logger = LoggerFactory.getLogger(JobVulnerabilityController.class);

    private final VulnerabilityService vulnerabilityService;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final JobRepository jobRepository;

    // ---------------------------
    // Single test endpoint
    // ---------------------------
    @PostMapping("/vulnerabilities/test")
    public ResponseEntity<VulnerabilityDTO> testSingle(@RequestBody TestRequest request) {
        logger.info("API: /vulnerabilities/test -> {}", request.getTargetUrl());
        Vulnerability v = vulnerabilityService.testVulnerability(
                request.getTargetUrl(),
                request.getVulnerabilityType(),
                request.getPayload()
        );
        return ResponseEntity.ok(toDTO(v));
    }

    // ---------------------------
    // Batch test endpoint
    // ---------------------------
    @PostMapping("/vulnerabilities/test/batch")
    public ResponseEntity<Map<String, Object>> testBatch(@RequestBody Object body) {
        List<TestRequest> batchRequests = extractBatch(body);
        if (batchRequests.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("error", "Batch vazio"));
        }

        logger.info("API: /vulnerabilities/test/batch -> batch size {}", batchRequests.size());
        Job job = vulnerabilityService.createBatchJob(batchRequests);

        Map<String, Object> resp = new HashMap<>();
        resp.put("jobId", job.getId());
        resp.put("status", job.getStatus());
        resp.put("targetUrl", job.getTargetUrl());
        return ResponseEntity.status(HttpStatus.CREATED).body(resp);
    }

    // ---------------------------
    // List vulnerabilities by Job ID
    // ---------------------------
    @GetMapping("/jobs/{id}/vulnerabilities")
    public ResponseEntity<List<VulnerabilityDTO>> getVulnerabilitiesByJob(@PathVariable Long id) {
        logger.info("API: /jobs/{}/vulnerabilities", id);
        List<Vulnerability> vulns = vulnerabilityRepository.findByJobId(id);

        if (vulns.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
        }

        List<VulnerabilityDTO> dtos = vulns.stream()
                .map(this::toDTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(dtos);
    }

    // ---------------------------
    // Return job report (PDF)
    // ---------------------------
    @PostMapping("/jobs/{id}/report")
    public ResponseEntity<byte[]> jobReport(@PathVariable Long id) {
        logger.info("API: /jobs/{}/report - gerando PDF", id);
        byte[] pdf = vulnerabilityService.generateReport(id);
        if (pdf == null || pdf.length == 0) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new byte[0]);
        }
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_PDF);
        headers.setContentDisposition(ContentDisposition.inline().filename("report_job_" + id + ".pdf").build());
        headers.setContentLength(pdf.length);
        return new ResponseEntity<>(pdf, headers, HttpStatus.OK);
    }

    // ---------------------------
    // Helpers
    // ---------------------------
    private List<TestRequest> extractBatch(Object body) {
        List<TestRequest> batchRequests = new ArrayList<>();

        if (body instanceof List<?> rawList) {
            for (Object o : rawList) {
                if (o instanceof Map<?, ?> m) batchRequests.add(mapToTestRequest(m));
            }
        } else if (body instanceof Map<?, ?> map) {
            Object b = map.get("batch");
            if (b instanceof List<?> rawList) {
                for (Object o : rawList) {
                    if (o instanceof Map<?, ?> m) batchRequests.add(mapToTestRequest(m));
                }
            }
        }
        return batchRequests;
    }

    private TestRequest mapToTestRequest(Map<?, ?> m) {
        TestRequest tr = new TestRequest();
        Object url = m.get("targetUrl");
        Object type = m.get("vulnerabilityType");
        Object payload = m.get("payload");
        if (url != null) tr.setTargetUrl(url.toString());
        if (type != null) tr.setVulnerabilityType(type.toString());
        if (payload != null) tr.setPayload(payload.toString());
        return tr;
    }

    private VulnerabilityDTO toDTO(Vulnerability v) {
        if (v == null) return null;
        return new VulnerabilityDTO(
                v.getId(),
                v.getName(),
                v.getTargetUrl(),
                v.getVulnerabilityType(),
                v.getPayload(),
                v.getResult(),
                v.getResponseDetails(),
                v.getCategory(),
                v.getSeverity(),
                v.getCreatedAt(),
                v.getJob() != null ? v.getJob().getId() : null,
                v.getHttpStatus() == null ? 0 : v.getHttpStatus()
        );
    }
}
