package com.example.bugbounty.controller;

import com.example.bugbounty.dto.VulnerabilityDTO;
import com.example.bugbounty.entity.Vulnerability;
import com.example.bugbounty.model.TestRequest;
import com.example.bugbounty.service.VulnerabilityService;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.*;

@RestController
@RequestMapping("/vulnerabilities")
@RequiredArgsConstructor
public class VulnerabilityController {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityController.class);
    private final VulnerabilityService vulnerabilityService;
    private final Environment env;
    private List<String> allowedDomains;

    @PostConstruct
    public void init() {
        this.allowedDomains = resolveAllowedDomains(env);
        logger.info("DOMÍNIOS PERMITIDOS: {}", allowedDomains);
    }

    @PostMapping("/test")
    public ResponseEntity<VulnerabilityDTO> test(@RequestBody TestRequest request) {
        String url = request.getTargetUrl();
        if (!isInScope(url)) {
            logger.warn("403 FORBIDDEN: URL fora do escopo → {}", url);
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(new VulnerabilityDTO(null, "Forbidden", url, "Scope Error", "", "BLOCKED",
                            "URL não está no escopo permitido.", "Security", "Critical", null, null, 403));
        }

        logger.info("Testando: {} → {}", request.getVulnerabilityType(), url);
        Vulnerability v = vulnerabilityService.testVulnerability(url, request.getVulnerabilityType(), request.getPayload());
        return ResponseEntity.ok(toDTO(v));
    }

    private boolean isInScope(String url) {
        try {
            URI uri = new URI(url);
            String host = uri.getHost();
            if (host == null || host.isBlank()) return false;

            String cleanHost = host.toLowerCase();
            String hostWithoutPort = cleanHost.split(":")[0];

            logger.debug("Validando: {} → Host: {} → Sem porta: {}", url, host, hostWithoutPort);

            return allowedDomains.stream()
                    .map(String::toLowerCase)
                    .anyMatch(domain ->
                        hostWithoutPort.equals(domain) ||
                        (hostWithoutPort.equals("127.0.0.1") && domain.equals("localhost")) ||
                        hostWithoutPort.endsWith("." + domain)
                    );
        } catch (Exception e) {
            logger.error("Erro ao validar URL: {}", url, e);
            return false;
        }
    }

    private List<String> resolveAllowedDomains(Environment env) {
        String csv = env.getProperty("bugbounty.allowed-domains", "");
        if (csv.isBlank()) return Collections.emptyList();
        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(s -> s.split(":")[0])
                .toList();
    }

    private VulnerabilityDTO toDTO(Vulnerability v) {
        return new VulnerabilityDTO(
                v.getId(),
                Optional.ofNullable(v.getName()).orElse(v.getVulnerabilityType()),
                v.getTargetUrl(),
                v.getVulnerabilityType(),
                Optional.ofNullable(v.getPayload()).orElse(""),
                Optional.ofNullable(v.getResult()).orElse("UNKNOWN"),
                Optional.ofNullable(v.getResponseDetails()).orElse(""),
                Optional.ofNullable(v.getCategory()).orElse("Unknown"),
                Optional.ofNullable(v.getSeverity()).orElse("Unknown"),
                v.getCreatedAt(),
                v.getJob() != null ? v.getJob().getId() : null,
                Optional.ofNullable(v.getHttpStatus()).orElse(0)
        );
    }
}