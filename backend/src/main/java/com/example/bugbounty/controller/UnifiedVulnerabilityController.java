package com.example.bugbounty.controller;

import com.example.bugbounty.dto.VulnerabilityDTO;
import com.example.bugbounty.entity.Job;
import com.example.bugbounty.entity.Vulnerability;
import com.example.bugbounty.model.TestRequest;
import com.example.bugbounty.repository.JobRepository;
import com.example.bugbounty.repository.VulnerabilityRepository;
import com.example.bugbounty.service.VulnerabilityService;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "*")
@RequiredArgsConstructor
public class UnifiedVulnerabilityController {

    private static final Logger logger = LoggerFactory.getLogger(UnifiedVulnerabilityController.class);

    private final VulnerabilityService vulnerabilityService;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final JobRepository jobRepository;

    @PostMapping("/vulnerabilities/test")
    public ResponseEntity<VulnerabilityDTO> testSingle(@RequestBody TestRequest request) {
        logger.info("API: /vulnerabilities/test -> {}", request.getTargetUrl());
        Vulnerability v = vulnerabilityService.testVulnerability(
                request.getTargetUrl(),
                request.getVulnerabilityType(),
                request.getPayload()
        );
        return ResponseEntity.ok(toDTO(v));
    }

    @PostMapping("/vulnerabilities/test/batch")
    public ResponseEntity<Map<String, Object>> testBatch(@RequestBody List<TestRequest> requests) {
        if (requests.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("error", "Batch vazio"));
        }
        logger.info("API: /vulnerabilities/test/batch -> batch size {}", requests.size());
        Job job = vulnerabilityService.createBatchJob(requests);
        Map<String, Object> resp = new HashMap<>();
        resp.put("jobId", job.getId());
        resp.put("status", job.getStatus());
        resp.put("targetUrl", job.getTargetUrl());
        return ResponseEntity.status(HttpStatus.CREATED).body(resp);
    }

    @GetMapping("/jobs/{id}/vulnerabilities")
    public ResponseEntity<List<VulnerabilityDTO>> getVulnerabilitiesByJob(@PathVariable Long id) {
        List<Vulnerability> vulns = vulnerabilityRepository.findByJobId(id);
        if (vulns.isEmpty()) return ResponseEntity.noContent().build();
        return ResponseEntity.ok(vulns.stream().map(this::toDTO).toList());
    }

    @PostMapping("/jobs/{id}/report")
    public ResponseEntity<byte[]> jobReport(@PathVariable Long id) {
        logger.info("API: /jobs/{}/report - gerando TXT", id);
        vulnerabilityService.generateReport(id);

        String path = "reports/report_job_" + id + ".txt";
        File file = new File(path);
        if (!file.exists()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body("Relatório não encontrado".getBytes());
        }

        try {
            byte[] txtBytes = Files.readAllBytes(Paths.get(path));
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.TEXT_PLAIN);
            headers.setContentDisposition(ContentDisposition.inline()
                    .filename("report_job_" + id + ".txt").build());
            headers.setContentLength(txtBytes.length);
            return new ResponseEntity<>(txtBytes, headers, HttpStatus.OK);
        } catch (IOException e) {
            logger.error("Erro ao ler TXT", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/test")
    public ResponseEntity<VulnerabilityDTO> testAny(@RequestBody TestRequest request) {
        logger.info("API: /test -> {}", request.getTargetUrl());
        Vulnerability v = vulnerabilityService.testVulnerability(
                request.getTargetUrl(),
                request.getVulnerabilityType(),
                request.getPayload()
        );
        return ResponseEntity.ok(toDTO(v));
    }

    @PostMapping("/test/batch")
    public ResponseEntity<Map<String, Object>> batchAny(@RequestBody List<TestRequest> requests) {
        if (requests.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("error", "Lista vazia"));
        }
        Job job = vulnerabilityService.createBatchJob(requests);
        return ResponseEntity.ok(Map.of(
                "jobId", job.getId(),
                "status", job.getStatus(),
                "report", job.getReportPath(),
                "message", "Job criado"
        ));
    }

    @GetMapping("/job/{jobId}")
    public ResponseEntity<List<VulnerabilityDTO>> listByJob(@PathVariable Long jobId) {
        return ResponseEntity.ok(vulnerabilityRepository.findByJobId(jobId)
                .stream().map(this::toDTO).toList());
    }

    @GetMapping("/export/{jobId}")
    public ResponseEntity<ByteArrayResource> exportTxt(@PathVariable Long jobId) {
        String path = "reports/report_job_" + jobId + ".txt";
        File file = new File(path);
        if (!file.exists()) return ResponseEntity.notFound().build();

        try {
            byte[] txtBytes = Files.readAllBytes(Paths.get(path));
            ByteArrayResource resource = new ByteArrayResource(txtBytes);
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION,
                            "attachment; filename=relatorio_job_" + jobId + ".txt")
                    .contentType(MediaType.TEXT_PLAIN)
                    .contentLength(txtBytes.length)
                    .body(resource);
        } catch (IOException e) {
            logger.error("Erro ao exportar TXT", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/vulnerabilities")
    public ResponseEntity<List<VulnerabilityDTO>> listAll() {
        return ResponseEntity.ok(vulnerabilityRepository.findAll()
                .stream().map(this::toDTO).toList());
    }

    /**
     * Aliás compat para /jobs/test usado pelo frontend.
     * Agora cria um job simples e define status baseado no resultado do teste único.
     */
    @PostMapping("/jobs/test")
    public ResponseEntity<Map<String, String>> aliasJobsTest(@RequestBody TestRequest request) {
        logger.info("Compat: /jobs/test -> {}", request.getTargetUrl());
        Vulnerability v = vulnerabilityService.testVulnerability(
                request.getTargetUrl(),
                request.getVulnerabilityType(),
                request.getPayload()
        );

        Job job = new Job();
        job.setTargetUrl(request.getTargetUrl());
        job.setVulnerabilityType(request.getVulnerabilityType());
        job.setSeverity(v.getSeverity() != null ? v.getSeverity() : "Unknown");

        // Define status do job com base no resultado do vulnerability
        String result = v.getResult() != null ? v.getResult() : "UNKNOWN";
        if ("VULNERABLE".equalsIgnoreCase(result)) {
            job.setStatus("VULNERABLE");
        } else if ("NOT_VULNERABLE".equalsIgnoreCase(result)) {
            job.setStatus("SAFE");
        } else if ("ERROR".equalsIgnoreCase(result)) {
            job.setStatus("ERROR");
        } else {
            job.setStatus("TESTED");
        }

        job = jobRepository.save(job);

        return ResponseEntity.ok(Map.of(
                "message", "Teste concluído!",
                "severity", job.getSeverity(),
                "status", job.getStatus(),
                "jobId", String.valueOf(job.getId())
        ));
    }

    private VulnerabilityDTO toDTO(Vulnerability v) {
        if (v == null) return null;
        return new VulnerabilityDTO(
                v.getId(),
                v.getName() != null ? v.getName() : v.getVulnerabilityType(),
                v.getTargetUrl(),
                v.getVulnerabilityType(),
                v.getPayload() != null ? v.getPayload() : "",
                v.getResult() != null ? v.getResult() : "UNKNOWN",
                v.getResponseDetails() != null ? v.getResponseDetails() : "",
                v.getCategory() != null ? v.getCategory() : "Unknown",
                v.getSeverity() != null ? v.getSeverity() : "Unknown",
                v.getCreatedAt(),
                v.getJob() != null ? v.getJob().getId() : null,
                v.getHttpStatus() != null ? v.getHttpStatus() : 0
        );
    }
}
