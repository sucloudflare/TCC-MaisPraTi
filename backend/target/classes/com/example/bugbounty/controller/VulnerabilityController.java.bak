// src/main/java/com/example/bugbounty/controller/VulnerabilityController.java
package com.example.bugbounty.controller;

import com.example.bugbounty.dto.VulnerabilityDTO;
import com.example.bugbounty.entity.Job;
import com.example.bugbounty.entity.Vulnerability;
import com.example.bugbounty.model.TestRequest;
import com.example.bugbounty.repository.VulnerabilityRepository;
import com.example.bugbounty.service.VulnerabilityService;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/vulnerabilities")
@CrossOrigin(origins = {"http://localhost:3000", "http://localhost:5173", "http://localhost:8080"})
public class VulnerabilityController {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityController.class);

    private final VulnerabilityRepository vulnerabilityRepository;
    private final VulnerabilityService vulnerabilityService;
    private final List<String> allowedDomains;

    @Autowired
    public VulnerabilityController(
            VulnerabilityRepository vulnerabilityRepository,
            VulnerabilityService vulnerabilityService,
            Environment env
    ) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.vulnerabilityService = vulnerabilityService;
        this.allowedDomains = resolveAllowedDomains(env);
    }

    @PostConstruct
    public void init() {
        logger.info("‚úÖ VulnerabilityController iniciado com sucesso");
        logger.info("üåê DOM√çNIOS PERMITIDOS: {}", allowedDomains);
    }

    // ========= TESTE INDIVIDUAL =========
    @PostMapping("/test")
    public ResponseEntity<VulnerabilityDTO> test(@RequestBody TestRequest request) {
        String url = request.getTargetUrl();
        if (!isInScope(url)) {
            logger.warn("403 FORBIDDEN: URL fora do escopo ‚Üí {}", url);
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(new VulnerabilityDTO(null, "Forbidden", url, "Scope Error", "", "BLOCKED",
                    "URL n√£o est√° no escopo permitido.", "Security", "Critical", null, null, 403));
        }

        logger.info("üîç Testando vulnerabilidade: {} ‚Üí {}", request.getVulnerabilityType(), url);
        Vulnerability v = vulnerabilityService.testVulnerability(
            url,
            request.getVulnerabilityType(),
            request.getPayload()
        );

        return ResponseEntity.ok(toDTO(v));
    }

    // ========= TESTE EM LOTE =========
    @PostMapping("/test/batch")
    public ResponseEntity<Map<String, Object>> batch(@RequestBody List<TestRequest> requests) {
        if (requests.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("error", "Lista de requisi√ß√µes vazia"));
        }

        boolean allInScope = requests.stream()
            .allMatch(r -> isInScope(r.getTargetUrl()));

        if (!allInScope) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(Map.of("error", "Uma ou mais URLs est√£o fora do escopo permitido"));
        }

        Job job = vulnerabilityService.createBatchJob(requests);
        return ResponseEntity.ok(Map.of(
            "jobId", job.getId(),
            "status", job.getStatus(),
            "report", job.getReportPath(),
            "message", "Job criado com sucesso"
        ));
    }

    // ========= LISTAR TODOS =========
    @GetMapping
    public ResponseEntity<List<VulnerabilityDTO>> listAll() {
        List<Vulnerability> vulns = vulnerabilityRepository.findAll();
        List<VulnerabilityDTO> dtos = vulns.stream().map(this::toDTO).collect(Collectors.toList());
        return ResponseEntity.ok(dtos);
    }

    // ========= LISTAR POR JOB =========
    @GetMapping("/job/{jobId}")
    public ResponseEntity<List<VulnerabilityDTO>> listByJob(@PathVariable Long jobId) {
        List<Vulnerability> vulns = vulnerabilityRepository.findByJobId(jobId);
        List<VulnerabilityDTO> dtos = vulns.stream().map(this::toDTO).collect(Collectors.toList());
        return ResponseEntity.ok(dtos);
    }

    // ========= EXPORTAR PDF =========
    @GetMapping("/export/{jobId}")
    public ResponseEntity<ByteArrayResource> exportPdf(@PathVariable Long jobId) {
        byte[] pdfBytes = vulnerabilityService.generateReport(jobId);

        if (pdfBytes.length == 0) {
            return ResponseEntity.notFound().build();
        }

        ByteArrayResource resource = new ByteArrayResource(pdfBytes);

        return ResponseEntity.ok()
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=relatorio_job_" + jobId + ".pdf")
            .contentType(MediaType.APPLICATION_PDF)
            .contentLength(pdfBytes.length)
            .body(resource);
    }

    // ========= VALIDA√á√ÉO DE ESCOPO =========
    private boolean isInScope(String url) {
        try {
            URI uri = new URI(url);
            String host = uri.getHost();
            if (host == null || host.isBlank()) {
                logger.warn("Host inv√°lido: {}", url);
                return false;
            }

            String cleanHost = host.toLowerCase().split(":")[0];
            boolean allowed = allowedDomains.stream()
                .map(String::toLowerCase)
                .anyMatch(domain ->
                    cleanHost.equals(domain) || cleanHost.endsWith("." + domain)
                );

            logger.debug("Valida√ß√£o de escopo: {} ‚Üí {}", cleanHost, allowed ? "PERMITIDO" : "BLOQUEADO");
            return allowed;

        } catch (Exception e) {
            logger.error("Erro ao validar URL: {}", url, e);
            return false;
        }
    }

    // ========= RESOLVE DOM√çNIOS DO YAML OU CSV =========
    private List<String> resolveAllowedDomains(Environment env) {
        String[] domainsArray = env.getProperty("bugbounty.allowed-domains", String[].class);

        if (domainsArray != null && domainsArray.length > 0) {
            return Arrays.stream(domainsArray)
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .toList();
        }

        String domainsCsv = env.getProperty("bugbounty.allowed-domains", "");
        if (domainsCsv.isBlank()) return Collections.emptyList();

        return Arrays.stream(domainsCsv.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .toList();
    }

    // ========= CONVERS√ÉO PARA DTO =========
    private VulnerabilityDTO toDTO(Vulnerability v) {
        return new VulnerabilityDTO(
            v.getId(),
            v.getName() != null ? v.getName() : v.getVulnerabilityType(),
            v.getTargetUrl(),
            v.getVulnerabilityType(),
            v.getPayload() != null ? v.getPayload() : "",
            v.getResult() != null ? v.getResult() : "UNKNOWN",
            v.getResponseDetails() != null ? v.getResponseDetails() : "",
            v.getCategory() != null ? v.getCategory() : "Unknown",
            v.getSeverity() != null ? v.getSeverity() : "Unknown",
            v.getCreatedAt(),
            v.getJob() != null ? v.getJob().getId() : null,
            v.getHttpStatus() != null ? v.getHttpStatus() : 0
        );
    }
}
